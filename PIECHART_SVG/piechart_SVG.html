<html>
<head>
    <title>SVG Pie Chart Test</title>
    <style type="text/css" media="screen">
      svg {width: 100%; height: 100%;}
    </style>
    
</head>
<body>
    <div id="pieWrap" style="width:800px; height:800px;">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<!--       <path id="pathTest" d="M100,100 A50,50 0 1,1 0,100 L50,100 Z"style="fill:magenta;"/> -->
<!--       <path id="pathTest" d="M200,100 A100,100 0 0,1 100,200 L100,100 Z"style="stroke:red;fill:blue"> -->
<!--       <path id="pathTest" d="M100,100 A50,50 0 0,1 50,150"style="stroke:red;fill:blue"> -->
    </svg>
  </div>
  <script>

      var FXDATA = {
        minPieceCount : 2,
        xmlns         : "http://www.w3.org/2000/svg",
        maxAngle      : 359.9999,
        sErrorMSG     : {}
      };

      function PIE(elTarget, htOption) {
       if(!(htOption && typeof htOption === "object")) {
         console.error("option type is wrong");
       }

       this.elParentSVG = elTarget;

       this.htCore = {};
       this.aPiece = [];

       //set options
       try {this._setOption(htOption);} catch(err){console.error("[PIE] option error => ",err);}

      //set center position
       this.htCore.centerX = this.htCore.startX - this.htCore.radius;
       this.htCore.centerY = this.htCore.startY;

       this.nCount = 0;
       this.aElPath = [];
       this._aArc = [];
       this._aStart = [];

       this._makeCreatePath();
      }


      PIE.prototype = {

        constructor : PIE,

        _setOption : function(htOption) {

            var htCoreOption  = htOption.core;
            this.aPiece        = htOption.piece;

            //check. piece count
            if(this.aPiece.length < FXDATA.minPieceCount) throw Error("Require pie's piece datas");

            //check. piece distribution
            if( this.aPiece.reduce(function(pre,now){
                  if(typeof pre!== "number") pre = +pre[0];
                  return pre + (+now[0]);
             }) !== 100 ) throw Error ("the sum of pieceData should be 100");

            //check. core 
            var htDefaultCoreValue =  {
              startX:100,
              startY:100,
              radius:50,
              nMaxAngle:360,
              nIncrease:5,
            };

            for(var name in htDefaultCoreValue) {
              this.htCore[name] = htCoreOption[name] || htDefaultCoreValue[name];
            }
         },

        _createPathElements : function (nIndex) {
            //var _elParent = document.querySelector("#pieWrap > svg");

            this.aElPath[nIndex] = document.createElementNS(FXDATA.xmlns, "path");

            var _coords = this._getCoordProperty();

            this.aElPath[nIndex].setAttribute("id" , "elPath");
            this.aElPath[nIndex].setAttribute("d" , _coords);
            this.aElPath[nIndex].setAttribute("style" , "stroke:'';fill:"+this.aPiece[nIndex][1]);
            this.elParentSVG.appendChild(this.aElPath[nIndex]);
        },

        _getCoordProperty : function() {
          var _result = "M" + this.htCore.startX + " " + this.htCore.startY + " "+ 
                        "A" + this.htCore.radius + "," + this.htCore.radius + " "+ 
                        "0 0,1 "+
                        this.htCore.startX + ","+
                        this.htCore.startY + " "+
                        "L" + this.htCore.centerX + "," + this.htCore.centerY + " "+
                        "Z";
          return _result;
        },

         /*
         var segments = el.pathSegList;
         // Move : x,y ------> segments.getItem(0);
         // ARC : r1, r2, angle, largeArcFlag, sweepFlag, x, y ----->  segments.getItem(1);
         // LINE : x,y  ------> segments.getItem(2);
         */
        _setDataForSet : function(nIndex) {
            var aSegments = [];
            aSegments[nIndex] = this.aElPath[nIndex].pathSegList;
            this._aArc[nIndex] = aSegments[nIndex].getItem(1);
            this._aStart[nIndex] = aSegments[nIndex].getItem(0);
        },

        _makeCreatePath : function(){ 
            var nPathCount = this.aPiece.length;
            for(var i=0; i<nPathCount; i++) {
              this._createPathElements(i);
              this._setDataForSet(i);
            }
        },

        runAnimation : function() {

            var nA1,nB1;

            //condition of stop ANIMATION
            if(this.nCount >= FXDATA.maxAngle) return;

            //interval 만큼 증가
            this.nCount = this.nCount + this.htCore.nIncrease;

            //두 가지 그리기 시작.
            //nA1 = this.nCount * 0.3;
            //nB1 = this.nCount * this.aPiece[1][0]/100;
            nA1 = this.nCount * this.aPiece[0][0]/100;
            nB1 = nA1 + (this.nCount * this.aPiece[1][0]/100); //이건 마지막꺼니까.. 이렇게 해야지.

            //약속된 크기까지만 동작한다. 
            if(this.nCount > (this.htCore.nMaxAngle - this.htCore.nIncrease)) {
              this.nCount = FXDATA.maxAngle;
              nA1 = FXDATA.maxAngle * this.aPiece[0][0]/100;
            }

            /**
             * 리팩톨잉 포인인 
             * 함수로 분리한다. 
             * ApIECE를 푸르로 돌리는 방법 있을 듯. 
             * nA1, nCount는 변수로 묶어서 상황에 따라서 다르게 설정하면 된다. 
             * nA1 180도 플래그도 포함하기. 
             * 
             */
            //첫번째 것. 각도를 기준으로 x,y좌표값을 설정
            this._aArc[0].x = (this.htCore.startX - this.htCore.radius) + (+(Math.cos(Math.PI/180 * nA1))) * this.htCore.radius;
            this._aArc[0].y = (this.htCore.startY) + (+(Math.sin(Math.PI/180 * nA1))) * this.htCore.radius;

            //두번째 것.
            //두번째 부터는 start 설정 필요하다. 
            this._aStart[1].x = this._aArc[0].x;
            this._aStart[1].y = this._aArc[0].y;
            this._aArc[1].x = (this.htCore.startX - this.htCore.radius) + (+(Math.cos(Math.PI/180 * nB1))) * this.htCore.radius;
            this._aArc[1].y = (this.htCore.startY) + (+(Math.sin(Math.PI/180 * nB1))) * this.htCore.radius;

            this._aStart[2].x = this._aArc[1].x;
            this._aStart[2].y = this._aArc[1].y;
            this._aArc[2].x = (this.htCore.startX - this.htCore.radius) + (+(Math.cos(Math.PI/180 * this.nCount))) * this.htCore.radius;
            this._aArc[2].y = (this.htCore.startY) + (+(Math.sin(Math.PI/180 * this.nCount))) * this.htCore.radius;

            //180도가 넘으면 largeArcFlag를 변경해야 한다.
            //if(this.nCount >= 180) this._aArc[0].largeArcFlag = 1;
            if(nA1 >= 180) this._aArc[0].largeArcFlag = 1;

            //자기 자체 크기가 180이상인지를 체크하는 로직이다.
            if((this.nCount - nA1) >= 180 ) this._aArc[1].largeArcFlag = 1;
            this.timeCtl = setTimeout(this.runAnimation.bind(this), 16);
        },

        _resetAnimation : function() {
            this.nCount = 0;
            this._aArc[0].largeArcFlag = 0;
            clearTimeout(this.timeCtl);
        },

        reStartAnimation : function() {
            this._resetAnimation();
            this.runAnimation();
        }
    };

      /* START Service CODE */

      /**
      {core : {
          startX:200,
          startY:100,
          radius:100,
          nIncrease:6,
        },
        piece : 
        [[30,'red'], [50,'blue']]
      }
      */

      var oPy = new PIE( document.querySelector("#pieWrap svg"), {
                core : {
                  startX:200,
                  startY:100,
                  radius:100,
                  nIncrease:6,
                }, 
                piece :
                [[50,'magenta'], [20,'skyblue'], [30,'green']]
      });

      oPy.runAnimation();

    </script>
</body>