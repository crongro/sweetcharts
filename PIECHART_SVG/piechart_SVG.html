<html>
<head>
    <title>SVG Pie Chart Test</title>
    <style type="text/css" media="screen">
      svg {width: 100%; height: 100%;}
    </style>
    
</head>
<body>
    <div id="pieWrap" style="width:800px; height:800px;">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<!--       <path id="pathTest" d="M100,100 A50,50 0 1,1 0,100 L50,100 Z"style="fill:magenta;"/> -->
<!--       <path id="pathTest" d="M200,100 A100,100 0 0,1 100,200 L100,100 Z"style="stroke:red;fill:blue"> -->
<!--       <path id="pathTest" d="M100,100 A50,50 0 0,1 50,150"style="stroke:red;fill:blue"> -->
    </svg>
  </div>
  <script>
    /* 
     var ele = new PIE(
            document.querySelector("#pieWrap svg path"), {
              startX:value,
              startY:value,
              radius:value,
              nMaxAngle:value,
              nIncrease:value,
              strokeStyle:value,
              fillStyle:value
            });
    */

      function PIE(elTarget, htOption) {
       if(!htOption || typeof htOption !== "object") {
         console.error("option type is wrong");
       }

       this.elParentSVG = elTarget;

       this._setOption(htOption);

       //중심좌표 
       this.centerX = this.startX - this.radius;
       this.centerY = this.startY;

       this.nCount = 0;
       this.aElPath = [];
       this._aArc = [];
       this._aStart = [];

       //TODO. change index number
       var nPathCount = 2;
       for(var i=0; i<nPathCount; i++) {
        this._createPathElements(i);
        this._setDataForSet(i);
       }

      }

      PIE.prototype = {

        constructor : PIE,

        _setOption : function(htOption) {
         //SET Default value
         //TODO. default 값 다른곳에 저장해두자.
         var htDefaultValue =  {
                startX:100,
                startY:100,
                radius:50,
                nMaxAngle:180,
                nIncrease:5,
                strokeStyle:"",
                fillStyle:"#000"
         };

         for(var name in htDefaultValue) {
          this[name] = htOption[name] || htDefaultValue[name];
         }
       },

      _createPathElements : function (nIndex) {
        var xmlns = "http://www.w3.org/2000/svg";
        //var _elParent = document.querySelector("#pieWrap > svg");

        this.aElPath[nIndex] = document.createElementNS(xmlns, "path");

        var _coords = this._setCoordValue();

        this.aElPath[nIndex].setAttribute("id" , "elPath");
        this.aElPath[nIndex].setAttribute("d" , _coords);
        this.aElPath[nIndex].setAttribute("style" , "stroke:"+this.strokeStyle+";fill:"+this.fillStyle);
        this.elParentSVG.appendChild(this.aElPath[nIndex]);
      },

      _setCoordValue : function() {

        var _result = "M" + this.startX + " " + this.startY + " "+ 
                      "A" + this.radius + "," + this.radius + " "+ 
                      "0 0,1 "+
                      this.startX + ","+
                      this.startY + " "+
                      "L" + this.centerX + "," + this.centerY + " "+
                      "Z";
        return _result;
      },

       /*
       var segments = el.pathSegList;
       // Move : x,y ------> segments.getItem(0);
       // ARC : r1, r2, angle, largeArcFlag, sweepFlag, x, y ----->  segments.getItem(1);
       // LINE : x,y  ------> segments.getItem(2);
       */
      _setDataForSet : function(nIndex) {
        var aSegments = [];
        aSegments[nIndex] = this.aElPath[nIndex].pathSegList;
        this._aArc[nIndex] = aSegments[nIndex].getItem(1);
        this._aStart[nIndex] = aSegments[nIndex].getItem(0);
      },

      runAnimation : function() {

          var nA1,nA2;

          var N_MAX_ANGLE = 359.9999;

          if(this.nCount >= N_MAX_ANGLE) return;

          //interval 만큼 증가
          this.nCount = this.nCount + this.nIncrease;

          //두 가지 그리기 시작.
          nA1 = this.nCount * 0.3; //첫번째 원은 count의 반값이다.
          nB1 = this.nCount;

          //약속된 크기까지만 동작한다. 
          if(this.nCount > (this.nMaxAngle - this.nIncrease)) {
            this.nCount = N_MAX_ANGLE;
            nA1 = N_MAX_ANGLE * 0.3;
          }

          //첫번째 것. 각도를 기준으로 x,y좌표값을 설정
          // this._aArc[0].x = (this.startX - this.radius) + (+(Math.cos(Math.PI/180 * this.nCount))) * this.radius;
          // this._aArc[0].y = (this.startY) + (+(Math.sin(Math.PI/180 * this.nCount))) * this.radius;
          var _pre = (this.startX - this.radius) + (+(Math.cos(Math.PI/180 * nA1))) * this.radius;
          var _after = (this.startY) + (+(Math.sin(Math.PI/180 * nA1))) * this.radius;
          this._aArc[0].x =  _pre;
          this._aArc[0].y =  _after;

          //두번째 것.
          this._aStart[1].x = _pre;
          this._aStart[1].y = _after;
          this._aArc[1].x = (this.startX - this.radius) + (+(Math.cos(Math.PI/180 * nB1))) * this.radius;
          this._aArc[1].y = (this.startY) + (+(Math.sin(Math.PI/180 * nB1))) * this.radius;

          //180도가 넘으면 largeArcFlag를 변경해야 한다.
          //if(this.nCount >= 180) this._aArc[0].largeArcFlag = 1;
          if(nA1 >= 180) this._aArc[0].largeArcFlag = 1;
          //자기 자체 크기가 180이상인지를 체크하는 로직이다.
          if((nB1 -nA1) >= 180 ) this._aArc[1].largeArcFlag = 1;
          this.timeCtl = setTimeout(this.runAnimation.bind(this), 16);
      },

      _resetAnimation : function() {
        this.nCount = 0;
        this._aArc[0].largeArcFlag = 0;
        clearTimeout(this.timeCtl);
      },

      reStartAnimation : function() {
        this._resetAnimation();
        this.runAnimation();
      }
    };

      /* START Service CODE */

      //default value
      //var oPy = new PIE(document.querySelector("#pieWrap svg"), {});

      var oPy = new PIE( document.querySelector("#pieWrap svg"), {
              startX:200,
              startY:100,
              radius:100,
              nMaxAngle:360,
              nIncrease:6, /* 이걸증가시키면 그만큼 animation은 끊긴다. */
              strokeStyle:"green",
              fillStyle:"gray"
      });

      oPy.runAnimation();

    </script>
</body>