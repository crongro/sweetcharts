<html>
<head>
    <title>SVG Pie Chart Test</title>
    <meta name="viewport" content="width=device-width">
    <style type="text/css" media="screen">
      svg {
        width: 100%;
        height: 100%;
      }
      #wrap {
        min-width: 1050px;
        padding-top: 20px;
      }
      #pieWrap {
        background-color: steelblue;
        float:left;
      }
      #leftDesc {
        float: left;
        width: 200px;
        margin-left: 50px;
        text-align: center;
        line-height: 2em;
      }

    @media (max-width: 600px) {
        #wrap {
          min-width: 320px;
          background-color: "red";
        }
        #wrap, #leftDesc{
          float: none;
        }
   }
</style>
    
</head>
<body>
<div id="wrap">
  <div id="pieWrap" style="width:600px; height:600px;">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    </svg>
  </div>

  <section id="leftDesc">
    <h2>PIEANI.js DEMO</h2>
    <p>
      Lorem ipsum dolor sit amet, consectetur adipisicing elit. Quod illum sint inventore dolorem, modi consectetur doloribus ipsum omnis. Inventore corporis hic nobis quidem reprehenderit qui amet, nemo error accusamus eligendi?
    </p>
  </section>
</div>

  <script>

      var FXDATA = {
        minPieceCount       : 2,
        nAniTime            : 16,
        xmlns               : "http://www.w3.org/2000/svg",
        maxAngle            : 359.9999,
        sErrorMSG           : {
              OPTION_TYPE_ERROR : "option type is wrong",
              REQ_PIECE_DATA    : "Require pie's piece datas",
              SUM_ERROR         : "the sum of pieceData should be 100"
        },
        htDefaultCoreValue  : {
              startX:100, startY:100, radius:50, nMaxAngle:360, nMilliSecondCycle : 1000, nIncrease:5
        }
      };

      function PIE(elTarget, htOption) {
       if(!(htOption && typeof htOption === "object")) {
           if(window.console) console.error(FXDATA.sErrorMSG.OPTION_TYPE_ERROR);
           return null;
       }

       this.elParentSVG = elTarget;

       this.htCore = {};
       this.aPiece = [];

       //set options
       try {this._setOption(htOption);} catch(errMsg){console.error(errMsg);}

      //set center position
       this.htCore.centerX = this.htCore.startX - this.htCore.radius;
       this.htCore.centerY = this.htCore.startY;

       this.nCount = 0;
       this.aElPath = [];
       this._aArc = [];
       this._aStart = [];

       this._makeCreatePathElement();
      }


      PIE.prototype = {
        _setOption : function(htOption) {

            var htCoreOption  = htOption.core;
            this.aPiece        = htOption.piece;

            //check. piece count
            if(this.aPiece.length < FXDATA.minPieceCount) throw Error(FXDATA.sErrorMSG.REQ_PIECE_DATA);

            //check. piece distribution
            if( this.aPiece.reduce(function(pre,now){
                  if(typeof pre!== "number") pre = +pre[0];
                  return pre + (+now[0]);
             }) !== 100 ) throw Error (FXDATA.sErrorMSG.SUM_ERROR);

            for(var name in FXDATA.htDefaultCoreValue) {
              this.htCore[name] = htCoreOption[name] || FXDATA.htDefaultCoreValue[name];
            }

            //100 is piece animation time(추정)
            this.htCore.nIncrease = (FXDATA.nAniTime * 360) / (htCoreOption.nMilliSecondCycle - 100);
         },

        _createPathElements : function (nIndex) {
            //var _elParent = document.querySelector("#pieWrap > svg");

            var g = document.createElementNS(FXDATA.xmlns, "g");
            this.elParentSVG.appendChild(g);

            this.aElPath[nIndex] = document.createElementNS(FXDATA.xmlns, "path");

            var _coords = this._getCoordProperty();

            this.aElPath[nIndex].setAttribute("id" , "elPath");
            this.aElPath[nIndex].setAttribute("d" , _coords);
            this.aElPath[nIndex].setAttribute("style" , "stroke:'';fill:"+this.aPiece[nIndex][1]);
            //this.elParentSVG.appendChild(this.aElPath[nIndex]);
            g.appendChild(this.aElPath[nIndex]);

          },

        _getCoordProperty : function() {
          var _result = "M" + this.htCore.startX + " " + this.htCore.startY + " "+ 
                        "A" + this.htCore.radius + "," + this.htCore.radius + " "+ 
                        "0 0,1 "+
                        this.htCore.startX + ","+
                        this.htCore.startY + " "+
                        "L" + this.htCore.centerX + "," + this.htCore.centerY + " "+
                        "Z";
          return _result;
        },

         /* var segments = el.pathSegList;
          * Move : x,y ------> segments.getItem(0);
          * ARC : r1, r2, angle, largeArcFlag, sweepFlag, x, y ----->  segments.getItem(1);
          * LINE : x,y  ------> segments.getItem(2);
          */
        _setDataForSet : function(nIndex) {
            var aSegments = [];
            aSegments[nIndex] = this.aElPath[nIndex].pathSegList;
            this._aArc[nIndex] = aSegments[nIndex].getItem(1);
            this._aStart[nIndex] = aSegments[nIndex].getItem(0);
        },

        _makeCreatePathElement : function(){ 
            var nPathCount = this.aPiece.length;
            for(var i=0; i<nPathCount; i++) {
              this._createPathElements(i);
              this._setDataForSet(i);
            }
        },

        //개별 running time : 0.1s 추정.
        runAnimation : function() {
            this._nR = 0;

            //condition of stop ANIMATION
            if(this.nCount >= FXDATA.maxAngle) {
              this._showTextData();
              this._showLastPiecePos();
              return;
            }

            //Increase 만큼 증가
            this.nCount = this.nCount + this.htCore.nIncrease;

            //최대값을 보정한다.
            if(this.nCount > (this.htCore.nMaxAngle - this.htCore.nIncrease)) this.nCount = FXDATA.maxAngle;

            this.aPiece.forEach(this._setSVGPathAttribute.bind(this));

            this.timeCtl = setTimeout(this.runAnimation.bind(this), 16);
        },

        _setSVGPathAttribute : function(v,i,o) {

            if(i > 0) {
              this._aStart[i].x = this._aArc[i-1].x;
              this._aStart[i].y = this._aArc[i-1].y;
            }

            //calculate piece Rangoe
            var _nPieceRange = this.nCount * v[0] / 100;
            this._nR += _nPieceRange;

            //set end Point
            this._aArc[i].x = (this.htCore.startX - this.htCore.radius) + (+(Math.cos(Math.PI/180 * this._nR))) * this.htCore.radius;
            this._aArc[i].y = (this.htCore.startY) + (+(Math.sin(Math.PI/180 * this._nR))) * this.htCore.radius;

            //change flag (if 180 degree)
            if((_nPieceRange) >= 180 && !this._aArc[i].largeArcFlag) this._aArc[i].largeArcFlag = 1;

            return this._nR; //for Array.map
        },

        _showLastPiecePos : function() {

            this.aPiece.forEach(function(v,i,o) {
                // console.log('start X[' + i + ']' + this._aStart[i].x);
                // console.log('start Y[' + i + ']' + this._aStart[i].y);
            }.bind(this));
        },

        _showTextData : function() {

            var aGcenterPos = [];
            var _ta;

            var aGangles = this.aPiece.map(this._setSVGPathAttribute.bind(this));

            //append to array value of Center piece angle.
            for(var i = 0; i< aGangles.length; i++){

                if(i === 0 ) _ta = Math.floor(aGangles[0]/2);
                else _ta = Math.floor((aGangles[i] - aGangles[i-1])/2 + aGangles[i-1]);

                var _tx = (this.htCore.startX - this.htCore.radius) + (+(Math.cos(Math.PI/180 * _ta))) * this.htCore.radius;
                var _ty = (this.htCore.startY) + (+(Math.sin(Math.PI/180 * _ta))) * this.htCore.radius;
                console.log(_tx,_ty);

                if(this.htCore.centerX < _tx)_tx = Math.floor(this.htCore.centerX + (_tx-this.htCore.centerX)/2);
                else _tx = Math.floor(this.htCore.centerX - (this.htCore.centerX - _tx)/2);

                if(this.htCore.centerY < _ty)_ty = Math.floor(this.htCore.centerY + (_ty-this.htCore.centerY)/2);
                else _ty = Math.floor(this.htCore.centerY - (this.htCore.centerY - _ty)/2);

                //_ty = Math.floor((_ty-this.htCore.centerY)/2);
                console.log(_tx, _ty);
                _appendText.apply(this,[i+1,_tx,_ty]);
            }

            //add text
            //var p = this.aElPath[nIndex];
            //todo. 이거 계속 바껴야 함...

            function _appendText(index,x,y) {
                var t = document.createElementNS("http://www.w3.org/2000/svg", "text");
                var elGs = this.elParentSVG.querySelector("g:nth-child("+index+")");

                var b = elGs.getBBox();
                //t.setAttribute("transform", "translate(" + (b.x + b.width/2) + " " + (b.y + b.height/2) + ")");
                //t.setAttribute("transform", "translate(" + (b.x + x) + " " + (b.y + y) + ")");
                t.setAttribute("transform", "translate(" + (x-16) + " " + y + ")");

                t.textContent = "12%";
                t.setAttribute("fill", "#000");
                t.setAttribute("font-size", "14");
                elGs.appendChild(t);
            }

            //p.parentNode.insertBefore(t, p.nextSibling);
            //g.appendChild(t);
          },

        _resetAnimation : function() {
            //this.nCount = 0;
            //this._aArc[0].largeArcFlag = 0;
            clearTimeout(this.timeCtl);
        },

        reStartAnimation : function() {
            this._resetAnimation();
            this.runAnimation();
        },
        constructor : PIE,
    };

      /* START Service CODE */
      var oPy = new PIE( document.querySelector("#pieWrap svg"), {
                core : {
                  startX:300,
                  startY:200,
                  radius:200,
                  nMilliSecondCycle:500,
                }, 
                piece :
                [[15,'magenta'], [3,'skyblue'], [2,'#fff'], [15,'blue'],[15,'yellow'],[15,'green'], [35,'brown']]
      });

      oPy.runAnimation();

    </script>
</body>